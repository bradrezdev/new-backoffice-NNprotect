Prompt para Implementaci√≥n del Sistema de Puntos y Billetera Virtual - NN Protect MLM
üìã Contexto del Proyecto
Informaci√≥n General
Empresa: NN Protect - Marketing Multinivel con esquema Uninivel
Productos: Suplementos y cuidado de la piel con nanotecnolog√≠a
Stack Tecnol√≥gico:
Framework: Reflex (Python-based)
ORM: SQLModel
Base de datos: Supabase (PostgreSQL)
Estado actual: ~5,700 usuarios activos (proyecci√≥n: 50,000 en 2 a√±os)
Arquitectura Actual
NNProtect_new_website/
‚îú‚îÄ‚îÄ database/              # Modelos SQLModel
‚îÇ   ‚îú‚îÄ‚îÄ users.py          # Tabla de usuarios con member_id
‚îÇ   ‚îú‚îÄ‚îÄ products.py       # 24 productos con precios por pa√≠s
‚îÇ   ‚îú‚îÄ‚îÄ orders.py         # √ìrdenes de compra
‚îÇ   ‚îú‚îÄ‚îÄ order_items.py    # Detalles de productos en √≥rdenes
‚îÇ   ‚îú‚îÄ‚îÄ comissions.py     # ‚úÖ Tabla EXISTENTE de comisiones
‚îÇ   ‚îú‚îÄ‚îÄ periods.py        # Per√≠odos mensuales de c√°lculo
‚îÇ   ‚îú‚îÄ‚îÄ ranks.py          # Cat√°logo de rangos MLM
‚îÇ   ‚îú‚îÄ‚îÄ user_rank_history.py  # Historial de rangos alcanzados
‚îÇ   ‚îú‚îÄ‚îÄ usertreepaths.py  # Genealog√≠a MLM (Path Enumeration)
‚îÇ   ‚îî‚îÄ‚îÄ exchange_rates.py # ‚úÖ Tasas de cambio fijas
Pa√≠ses Operativos y Monedas
M√©xico: MXN
USA: USD
Colombia: COP
Rep√∫blica Dominicana: DOP
Sistema de Doble Puntuaci√≥n (CR√çTICO)
# PV (Personal Volume) - Para alcanzar rangos
pv = {
    "proposito": "SOLO para calificaci√≥n de rangos",
    "caracteristica": "Valor uniforme global en todos los pa√≠ses",
    "ejemplo": "Producto C√∫rcuma = 293 PV (igual en MX, USA, COP, DOP)"
}

# VN (Valor Negocio) - Para pagar comisiones
vn = {
    "proposito": "SOLO para calcular comisiones monetarias",
    "caracteristica": "Valor localizado por pa√≠s",
    "ejemplo": "C√∫rcuma = 293 VN (MXN), 21 VN (USD), 67,400 VN (COP)"
}
üéØ Requerimientos del Sistema
1. Puntos NN Travel
Sistema de acumulaci√≥n de puntos para viajes mediante campa√±as semestrales.
Fuentes de Acumulaci√≥n
A. Por Kits de Inicio Comprados en la Red
kits_puntos = {
    "full_supplement": {
        "puntos_base": 1,
        "precio_mx": 1996,
        "precio_usa": 120,
        "precio_cop": 479000
    },
    "full_skin": {
        "puntos_base": 2,
        "precio_mx": 2596,
        "precio_usa": 160,
        "precio_cop": 622800
    },
    "full_protect": {
        "puntos_base": 4,
        "precio_mx": 5790,
        "precio_usa": 353,
        "precio_cop": 1389000,
        "bonificacion_especial": "+1 punto si inscribes 5 Full Protect"
    }
}
B. Por Rangos Alcanzados por el Usuario
Rango	Puntos Base	Puntos en Promo
Visionario	1	2
Emprendedor	5	10
Creativo	15	30
Innovador	25	50
Embajador Transformador	50	100
Embajador Inspirador	100	200
Embajador Consciente	200	200
Embajador Solidario	200	200
C. Por Rangos Alcanzados por Directos (Nivel 1) Los directos generan puntos con valores espec√≠ficos (ver tabla MLM_SCHEME_README l√≠neas 852-862).
Reglas de Negocio
nn_travel_rules = {
    "meta_actual": 200,  # Puntos requeridos para calificar
    "periodo": "semestral",  # Campa√±as de 6 meses
    "acumulacion": "progresiva",  # Se acumulan durante toda la campa√±a
    "calificacion": "al_completar_200",
    "reseteo": "cada_nueva_campa√±a"
}
Estructura de Datos Requerida
‚ö†Ô∏è IMPORTANTE: No existe tabla campaigns, debe crearse.
class TravelCampaigns(rx.Model, table=True):
    """
    Campa√±as semestrales de NN Travels.
    """
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(max_length=100)  # "Campa√±a 2025-H1", "Campa√±a 2025-H2"
    start_date: datetime
    end_date: datetime
    target_points: int = Field(default=200)  # Meta de puntos
    is_promo_active: bool = Field(default=False)  # Si hay puntos duplicados
    period_id: int = Field(foreign_key="periods.id", index=True)  # Per√≠odo asociado
    status: str = Field(default="active")  # active, closed
    created_at: datetime
Tabla Principal de Puntos
class NNTravelPoints(rx.Model, table=True):
    """
    Acumulaci√≥n de puntos NN Travel por usuario y campa√±a.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    campaign_id: int = Field(foreign_key="travelcampaigns.id", index=True)
    
    # Desglose de puntos
    points_from_kits: int = Field(default=0)  # Puntos por kits vendidos
    points_from_self_ranks: int = Field(default=0)  # Puntos por rangos propios
    points_from_direct_ranks: int = Field(default=0)  # Puntos por rangos de directos
    points_bonus: int = Field(default=0)  # Bonificaciones especiales
    
    total_points: int = Field(default=0)  # Total acumulado
    qualifies_for_travel: bool = Field(default=False)  # Califica si >= 200
    
    created_at: datetime
    updated_at: datetime
    
    __table_args__ = (
        UniqueConstraint('member_id', 'campaign_id'),
    )
Historial de Eventos
class NNTravelPointsHistory(rx.Model, table=True):
    """
    Registro detallado de cada evento que genera puntos.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    campaign_id: int = Field(foreign_key="travelcampaigns.id", index=True)
    
    event_type: str  # "kit_purchase", "self_rank", "direct_rank", "bonus"
    points_earned: int
    source_member_id: int | None = Field(default=None)  # Si viene de directo
    source_order_id: int | None = Field(default=None)  # Si viene de compra
    rank_achieved: str | None = Field(default=None)  # Si es por rango
    
    description: str  # Descripci√≥n del evento
    created_at: datetime
2. Puntos de Lealtad
Sistema de fidelizaci√≥n con regalo f√≠sico cada 4 meses consecutivos.
Reglas de Negocio CR√çTICAS
loyalty_rules = {
    "puntos_por_mes": 25,
    "puntos_requeridos": 100,  # 4 meses consecutivos
    "ventana_compra": "d√≠a 1-7 del mes",  # SOLO estas fechas cuentan
    "regla_reinicio": "si_un_mes_falla_resetea_a_0",  # ‚ö†Ô∏è MUY IMPORTANTE
    "frecuencia": "cada_4_meses",
    "regalo": ["paquete_5_suplementos", "paquete_3_serums_2_cremas"]
}
Flujo de Acumulaci√≥n
# Ejemplo del flujo cr√≠tico:
"""
Mes 1 (Ene 3): Compra ‚Üí 25 puntos
Mes 2 (Feb 5): Compra ‚Üí 50 puntos  
Mes 3 (Mar 15): NO compra en d√≠a 1-7 ‚Üí REINICIO a 0 puntos ‚ùå
Mes 4 (Abr 4): Compra ‚Üí 25 puntos (comenzando de nuevo)
"""
Estructura de Datos Requerida
class LoyaltyPoints(rx.Model, table=True):
    """
    Balance de puntos de lealtad por usuario.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", unique=True, index=True)
    
    current_points: int = Field(default=0)  # 0-100, se reinicia al canjear
    consecutive_months: int = Field(default=0)  # Meses consecutivos acumulados
    last_valid_purchase_date: datetime | None = Field(default=None)
    
    status: str = Field(default="ACUMULANDO")  # ACUMULANDO, CALIFICADO, CANJEADO, REINICIADO
    
    created_at: datetime
    updated_at: datetime
class LoyaltyPointsHistory(rx.Model, table=True):
    """
    Historial completo de acumulaciones/reinicios.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    period_id: int = Field(foreign_key="periods.id", index=True)
    
    event_type: str  # "EARNED", "RESET", "REDEEMED"
    points_before: int
    points_after: int
    points_change: int  # +25, -100, etc.
    
    order_id: int | None = Field(default=None, foreign_key="orders.id")
    purchase_day: int | None = Field(default=None)  # D√≠a del mes (1-31)
    
    description: str
    created_at: datetime
class LoyaltyRewards(rx.Model, table=True):
    """
    Registro de recompensas entregadas.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    
    reward_type: str  # "paquete_5_suplementos", "paquete_3_serums_2_cremas"
    delivery_order_id: int | None = Field(default=None, foreign_key="orders.id")
    
    earned_at: datetime  # Cu√°ndo complet√≥ 100 puntos
    delivered_at: datetime | None = Field(default=None)  # Cu√°ndo se entreg√≥
    status: str = Field(default="PENDING")  # PENDING, DELIVERED
3. Cashback
Descuento del 70% aplicable en la misma orden al alcanzar 2,930 PV.
Reglas de Negocio ACTUALIZADAS
cashback_rules = {
    "requisito_pv": 2930,  # PV m√≠nimo para activar
    "descuento_porcentaje": 70,  # 70% del precio p√∫blico
    "base_calculo": "total_precio_publico",  # Precio p√∫blico de TODOS los productos
    "productos_permitidos": "cualquier_producto_hasta_2930pv",
    "envio": "se_cobra_normal",  # El env√≠o NO tiene descuento
    "activacion": "en_tiempo_real_en_carrito",  # Se activa al alcanzar 2930 PV
    "misma_orden": "si",  # Se puede a√±adir productos del cashback a la MISMA orden
    "valido_hasta": "fin_del_mes",
    "se_aplica_en": "siguiente_compra_o_misma_orden"
}
Flujo de Activaci√≥n
# Ejemplo de flujo:
"""
1. Usuario a√±ade productos al carrito
2. Sistema calcula PV acumulado en tiempo real
3. Al llegar a 2,930 PV ‚Üí Sistema activa cashback
4. Usuario puede:
   a) A√±adir m√°s productos (hasta 2,930 PV adicionales) con 70% descuento
   b) O pagar y usar el cashback en siguiente compra del mismo mes
5. Descuento = 70% del precio p√∫blico de los productos del cashback
6. Env√≠o se cobra normal
"""
Estructura de Datos Requerida
class Cashback(rx.Model, table=True):
    """
    Registro de cashbacks generados y aplicados.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    period_id: int = Field(foreign_key="periods.id", index=True)
    
    # Orden que gener√≥ el cashback (alcanz√≥ 2,930 PV)
    generated_by_order_id: int = Field(foreign_key="orders.id", index=True)
    pv_accumulated: int  # PV que gener√≥ el cashback (debe ser >= 2,930)
    
    # Monto del descuento (70% del precio p√∫blico)
    discount_amount: float  # En moneda del usuario
    currency: str = Field(max_length=10)  # MXN, USD, COP, DOP
    
    # Aplicaci√≥n del descuento
    applied_to_order_id: int | None = Field(default=None, foreign_key="orders.id")
    
    # Vigencia
    issued_at: datetime
    expires_at: datetime  # Fin del mes
    
    # Estado
    status: str = Field(default="AVAILABLE")  # AVAILABLE, USED, EXPIRED
    
    created_at: datetime
    updated_at: datetime
class CashbackUsage(rx.Model, table=True):
    """
    Detalle de productos comprados con cashback.
    """
    id: int | None = Field(default=None, primary_key=True)
    cashback_id: int = Field(foreign_key="cashback.id", index=True)
    order_id: int = Field(foreign_key="orders.id", index=True)
    order_item_id: int = Field(foreign_key="orderitems.id", index=True)
    
    product_id: int = Field(foreign_key="products.id")
    quantity: int
    
    original_price: float  # Precio p√∫blico
    discount_applied: float  # 70% del precio p√∫blico
    final_price: float  # 30% del precio p√∫blico
    
    created_at: datetime
4. Billetera Virtual (Wallet)
Monedero electr√≥nico interno donde se depositan comisiones y se realizan transacciones.
Funcionalidades Core
wallet_features = {
    "recibir_comisiones": [
        "bono_rapido",
        "bono_uninivel", 
        "bono_matching",
        "bono_alcance",
        "bono_automovil",
        "bono_travels",
        "bono_cashback",
        "bono_lealtad"
    ],
    "pagar_ordenes": "usar_balance_wallet",
    "transferencias": {
        "enviar": "a_otros_usuarios",
        "recibir": "de_otros_usuarios"
    },
    "retiros": {
        "destino": "cuenta_bancaria",
        "minimo": "definir_por_pais"
    }
}
Integraci√≥n con Comisiones EXISTENTES
‚ö†Ô∏è CR√çTICO: Ya existe la tabla database/comissions.py con los siguientes campos:
class Commissions(rx.Model, table=True):
    id: int
    member_id: int  # Receptor
    bonus_type: str  # Tipo de bono
    source_member_id: int | None  # Origen
    source_order_id: int | None  # Orden origen
    period_id: int  # Per√≠odo
    level_depth: int | None  # Nivel de profundidad
    amount_vn: float  # Monto en VN
    currency_origin: str  # Moneda origen
    amount_converted: float  # Monto convertido
    currency_destination: str  # Moneda destino
    exchange_rate: float  # Tasa usada
    status: str  # PENDING, PAID, CANCELLED
    calculated_at: datetime
    paid_at: datetime | None
    notes: str | None
Flujo de Integraci√≥n Wallet ‚Üî Commissions
# Flujo completo:
"""
1. Sistema calcula comisiones ‚Üí Inserta en tabla `commissions` (status: PENDING)
2. Job de procesamiento lee comisiones PENDING
3. Por cada comisi√≥n:
   a) Deposita monto en wallet del usuario (WalletTransaction tipo COMMISSION_DEPOSIT)
   b) Actualiza commissions.status = PAID
   c) Actualiza commissions.paid_at = now()
4. Usuario puede consultar:
   - Total ganado por tipo de bono (SUM commissions GROUP BY bonus_type)
   - Total ganado por nivel (SUM commissions GROUP BY level_depth)
   - Balance actual en wallet
"""
Estructura de Datos Requerida
class Wallets(rx.Model, table=True):
    """
    Billetera virtual por usuario (una por usuario).
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", unique=True, index=True)
    
    balance: float = Field(default=0.0)  # Balance actual (NUNCA negativo)
    currency: str = Field(max_length=10)  # MXN, USD, COP, DOP (seg√∫n pa√≠s del usuario)
    
    status: str = Field(default="ACTIVE")  # ACTIVE, SUSPENDED, CLOSED
    
    created_at: datetime
    updated_at: datetime  # Se actualiza en cada transacci√≥n
    
    __table_args__ = (
        CheckConstraint('balance >= 0', name='balance_non_negative'),
    )
class WalletTransactionType(Enum):
    """Tipos de transacciones de billetera"""
    # Entradas (cr√©ditos)
    COMMISSION_DEPOSIT = "commission_deposit"  # Dep√≥sito de comisi√≥n
    TRANSFER_IN = "transfer_in"  # Transferencia recibida
    REFUND = "refund"  # Devoluci√≥n
    ADJUSTMENT_CREDIT = "adjustment_credit"  # Ajuste administrativo positivo
    
    # Salidas (d√©bitos)
    ORDER_PAYMENT = "order_payment"  # Pago de orden
    TRANSFER_OUT = "transfer_out"  # Transferencia enviada
    WITHDRAWAL_REQUEST = "withdrawal_request"  # Solicitud de retiro
    WITHDRAWAL_COMPLETED = "withdrawal_completed"  # Retiro completado
    WITHDRAWAL_REJECTED = "withdrawal_rejected"  # Retiro rechazado (reversa)
    ADJUSTMENT_DEBIT = "adjustment_debit"  # Ajuste administrativo negativo

class WalletTransactionStatus(Enum):
    """Estados de transacci√≥n"""
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class WalletTransactions(rx.Model, table=True):
    """
    Registro inmutable de todas las transacciones de billetera.
    CADA transacci√≥n debe quedar registrada permanentemente.
    """
    id: int | None = Field(default=None, primary_key=True)
    transaction_uuid: str = Field(unique=True, index=True)  # UUID para idempotencia
    
    # Usuario propietario de la wallet
    member_id: int = Field(foreign_key="users.member_id", index=True)
    
    # Tipo y estado
    transaction_type: str = Field(max_length=50, index=True)  # Enum WalletTransactionType
    status: str = Field(default="PENDING", index=True)  # Enum WalletTransactionStatus
    
    # Montos (puede ser negativo para d√©bitos)
    amount: float  # Monto de la transacci√≥n (+ para cr√©dito, - para d√©bito)
    balance_before: float  # Balance ANTES de la transacci√≥n
    balance_after: float  # Balance DESPU√âS de la transacci√≥n
    currency: str = Field(max_length=10)
    
    # Referencias externas
    commission_id: int | None = Field(default=None, foreign_key="commissions.id", index=True)
    order_id: int | None = Field(default=None, foreign_key="orders.id", index=True)
    transfer_to_member_id: int | None = Field(default=None, foreign_key="users.member_id")
    transfer_from_member_id: int | None = Field(default=None, foreign_key="users.member_id")
    
    # Metadatos
    description: str  # Descripci√≥n legible
    notes: str | None = Field(default=None, max_length=500)
    metadata_json: str | None = Field(default=None)  # JSON para datos adicionales
    
    # Timestamps (UTC puro)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={"server_default": func.now()}
    )
    completed_at: datetime | None = Field(default=None)
    
    # √çndices compuestos
    __table_args__ = (
        Index('idx_member_type', 'member_id', 'transaction_type'),
        Index('idx_member_status', 'member_id', 'status'),
        Index('idx_member_created', 'member_id', 'created_at'),
    )
class WalletWithdrawals(rx.Model, table=True):
    """
    Solicitudes de retiro a cuenta bancaria.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    wallet_transaction_id: int = Field(foreign_key="wallettransactions.id", unique=True)
    
    amount: float  # Monto solicitado
    currency: str = Field(max_length=10)
    
    # Datos bancarios (encriptados en producci√≥n)
    bank_name: str = Field(max_length=100)
    account_number: str = Field(max_length=50)
    account_holder_name: str = Field(max_length=150)
    
    # Estado y procesamiento
    status: str = Field(default="PENDING")  # PENDING, PROCESSING, COMPLETED, REJECTED
    rejection_reason: str | None = Field(default=None)
    
    requested_at: datetime
    processed_at: datetime | None = Field(default=None)
    completed_at: datetime | None = Field(default=None)
üìä Requerimientos de Visualizaci√≥n y Reportes
Dashboard del Usuario
El sistema debe permitir visualizar:
user_dashboard_requirements = {
    "comisiones_por_bono": {
        "query": "SELECT bonus_type, SUM(amount_converted) FROM commissions WHERE member_id=X GROUP BY bonus_type",
        "visualizacion": "Gr√°fico de barras o tabla"
    },
    "comisiones_por_nivel": {
        "query": "SELECT level_depth, SUM(amount_converted) FROM commissions WHERE member_id=X AND bonus_type='bono_uninivel' GROUP BY level_depth",
        "visualizacion": "Gr√°fico de l√≠neas por profundidad"
    },
    "balance_wallet": {
        "query": "SELECT balance FROM wallets WHERE member_id=X",
        "tiempo_real": True
    },
    "historial_transacciones": {
        "query": "SELECT * FROM wallettransactions WHERE member_id=X ORDER BY created_at DESC",
        "paginacion": True,
        "filtros": ["tipo", "fecha", "estado"]
    }
}
üîß Especificaciones T√©cnicas Generales
Convenciones de C√≥digo
# 1. Nombres de tablas: snake_case plural
# Correcto: wallets, wallet_transactions, loyalty_points
# Incorrecto: Wallet, walletTransaction, LoyaltyPoint

# 2. Campos comunes en TODAS las tablas
common_fields = {
    "id": "int | None = Field(default=None, primary_key=True)",
    "created_at": "datetime (UTC puro)",
    "updated_at": "datetime (UTC puro, opcional seg√∫n tabla)"
}

# 3. Montos monetarios: siempre Decimal o float con 2 decimales
amount: float = Field(default=0.0)  # Para montos
balance: float = Field(default=0.0)  # Para balances

# 4. Foreign Keys: siempre con ondelete apropiado
member_id: int = Field(foreign_key="users.member_id", index=True)

# 5. Timestamps: SIEMPRE en UTC puro
from datetime import datetime, timezone

created_at: datetime = Field(
    default_factory=lambda: datetime.now(timezone.utc),
    sa_column_kwargs={"server_default": func.now()}
)

# 6. Enums: siempre como clase Enum de Python
from enum import Enum

class StatusType(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
√çndices Requeridos
# √çndices cr√≠ticos para performance:

# Wallets
CREATE INDEX idx_wallet_member ON wallets(member_id);

# WalletTransactions
CREATE INDEX idx_wt_member_type ON wallettransactions(member_id, transaction_type);
CREATE INDEX idx_wt_member_created ON wallettransactions(member_id, created_at);
CREATE INDEX idx_wt_commission ON wallettransactions(commission_id);
CREATE INDEX idx_wt_order ON wallettransactions(order_id);

# NNTravelPoints
CREATE INDEX idx_nntp_member_campaign ON nntravelpoints(member_id, campaign_id);
CREATE INDEX idx_nntp_campaign ON nntravelpoints(campaign_id);

# LoyaltyPoints
CREATE INDEX idx_lp_member ON loyaltypoints(member_id);
CREATE INDEX idx_lp_status ON loyaltypoints(status);

# Cashback
CREATE INDEX idx_cb_member_period ON cashback(member_id, period_id);
CREATE INDEX idx_cb_status ON cashback(status);
Validaciones Cr√≠ticas
validations = {
    "wallet_balance": "NUNCA puede ser negativo (CHECK CONSTRAINT)",
    "transaction_atomicity": "Transferencias deben ser at√≥micas (2 registros: OUT + IN)",
    "idempotency": "Usar transaction_uuid para evitar duplicados",
    "commission_deposit": "Validar que commission.status == PENDING antes de depositar",
    "cashback_pv": "Validar que PV >= 2930 antes de generar cashback",
    "loyalty_day_validation": "Validar que compra sea entre d√≠a 1-7 del mes"
}
Constraints de Integridad
# Ejemplos de constraints necesarios:

# 1. Balance no negativo
__table_args__ = (
    CheckConstraint('balance >= 0', name='balance_non_negative'),
)

# 2. Unicidad compuesta
__table_args__ = (
    UniqueConstraint('member_id', 'campaign_id', name='unique_member_campaign'),
)

# 3. Foreign keys con comportamiento
member_id: int = Field(
    foreign_key="users.member_id",
    sa_column_kwargs={"ondelete": "CASCADE"}  # O "RESTRICT" seg√∫n caso
)
üéØ Casos de Uso Cr√≠ticos a Soportar
1. Dep√≥sito de Comisi√≥n a Wallet
"""
Flow:
1. Sistema calcula comisiones mensuales ‚Üí Inserta en `commissions` (PENDING)
2. Job procesa comisiones PENDING
3. Por cada comisi√≥n:
   a) Leer wallets.balance actual
   b) Crear WalletTransaction:
      - type: COMMISSION_DEPOSIT
      - amount: commission.amount_converted
      - balance_before: balance actual
      - balance_after: balance + amount
      - commission_id: commission.id
   c) Actualizar wallets.balance += amount
   d) Actualizar commissions.status = PAID, paid_at = now()
4. Commit transacci√≥n completa (todo o nada)
"""
2. Usuario Paga Orden con Wallet
"""
Flow:
1. Usuario confirma orden
2. Sistema valida: wallet.balance >= order.total
3. Si suficiente:
   a) Crear WalletTransaction:
      - type: ORDER_PAYMENT
      - amount: -order.total (negativo)
      - balance_before: balance actual
      - balance_after: balance - order.total
      - order_id: order.id
   b) Actualizar wallets.balance -= order.total
   c) Actualizar orders.payment_method = "wallet"
   d) Actualizar orders.payment_confirmed_at = now()
4. Commit transacci√≥n
"""
3. Transferencia entre Usuarios
"""
Flow:
1. Usuario A transfiere $500 a Usuario B
2. Validar: wallet_A.balance >= 500
3. Crear DOS transacciones (at√≥micamente):
   
   a) Transacci√≥n OUT (Usuario A):
      - type: TRANSFER_OUT
      - amount: -500
      - balance_before: balance_A
      - balance_after: balance_A - 500
      - transfer_to_member_id: user_B.id
   
   b) Transacci√≥n IN (Usuario B):
      - type: TRANSFER_IN
      - amount: +500
      - balance_before: balance_B
      - balance_after: balance_B + 500
      - transfer_from_member_id: user_A.id
   
4. Actualizar ambos wallets.balance
5. Commit TODO junto (rollback si falla cualquier paso)
"""
4. Activaci√≥n Autom√°tica de Cashback
"""
Flow:
1. Usuario a√±ade productos al carrito
2. Frontend calcula PV en tiempo real
3. Cuando PV >= 2930:
   a) Backend valida PV acumulado
   b) Calcula descuento 70% del precio p√∫blico
   c) Crea registro en tabla `cashback`:
      - generated_by_order_id: order.id (puede ser NULL si a√∫n no se paga)
      - discount_amount: total_precio_publico * 0.70
      - expires_at: fin del mes
      - status: AVAILABLE
   d) Frontend muestra descuento disponible
4. Usuario puede:
   - A√±adir m√°s productos con descuento en misma orden
   - O usar descuento en siguiente compra del mes
"""
5. Reset de Puntos de Lealtad
"""
Flow (Job autom√°tico d√≠a 8 de cada mes):
1. Leer todos los usuarios con loyalty_points > 0
2. Por cada usuario:
   a) Verificar si hubo compra entre d√≠a 1-7 del mes anterior
   b) Si NO hubo compra:
      - Crear LoyaltyPointsHistory:
        - event_type: RESET
        - points_before: puntos actuales
        - points_after: 0
        - description: "Reinicio por falta de compra en ventana 1-7"
      - Actualizar loyalty_points.current_points = 0
      - Actualizar loyalty_points.consecutive_months = 0
      - Actualizar loyalty_points.status = REINICIADO
3. Commit cambios
"""
üìã Entregables Esperados
Archivos a Crear
database/nn_travel_points.py
Clase TravelCampaigns
Clase NNTravelPoints
Clase NNTravelPointsHistory
database/loyalty_points.py
Clase LoyaltyPoints
Clase LoyaltyPointsHistory
Clase LoyaltyRewards
database/cashback.py
Clase Cashback
Clase CashbackUsage
Enums: CashbackStatus
database/wallet.py
Clase Wallets
Clase WalletTransactions
Clase WalletWithdrawals
Enums: WalletTransactionType, WalletTransactionStatus
Caracter√≠sticas de Cada Archivo
# Estructura esperada de cada archivo:

"""
1. Imports correctos
   - import reflex as rx
   - from sqlmodel import Field, func, Index, UniqueConstraint, CheckConstraint
   - from datetime import datetime, timezone
   - from enum import Enum

2. Enums (si aplica)
   - Definir todos los estados/tipos como Enum

3. Modelos SQLModel
   - Heredar de rx.Model
   - table=True
   - Docstrings explicativos en espa√±ol
   - Type hints correctos
   - Foreign keys apropiados
   - √çndices necesarios
   - Constraints de validaci√≥n

4. M√©todos helper (opcional pero recomendado)
   - M√©todos de instancia √∫tiles
   - Properties calculadas
   - Validaciones custom

5. Comentarios explicativos
   - Para reglas de negocio complejas
   - Para campos cr√≠ticos
   - Para constraints importantes
"""
‚úÖ Checklist de Validaci√≥n
Antes de entregar, verificar:
 Todos los modelos heredan de rx.Model con table=True
 Todos los timestamps est√°n en UTC puro
 Todos los montos usan float o Decimal
 Todas las Foreign Keys tienen √≠ndices
 Constraints de validaci√≥n implementados (CHECK, UNIQUE)
 Enums definidos para estados y tipos
 Campos created_at y updated_at donde corresponda
 √çndices compuestos para queries frecuentes
 Docstrings en espa√±ol en todas las clases
 Nombres de tablas en snake_case plural
 Compatibilidad con tablas existentes (users, orders, commissions, periods)
 Validaci√≥n de que cashback se conecta con orders
 Validaci√≥n de que wallet_transactions se conecta con commissions
 Validaci√≥n de que travel_campaigns tiene period_id
üö® Consideraciones Cr√≠ticas Finales
Atomicidad de Transacciones
# TODAS las operaciones de wallet deben ser at√≥micas:
with db.begin():
    # 1. Validar balance
    # 2. Crear WalletTransaction
    # 3. Actualizar Wallets.balance
    # 4. Actualizar tabla relacionada (commissions, orders, etc.)
    # Si CUALQUIER paso falla ‚Üí ROLLBACK completo
Idempotencia
# Usar transaction_uuid para evitar duplicados:
transaction_uuid = str(uuid.uuid4())

# Antes de insertar, verificar:
existing = db.query(WalletTransactions).filter(
    WalletTransactions.transaction_uuid == transaction_uuid
).first()

if existing:
    return existing  # Ya procesado, no duplicar
Auditor√≠a Completa
# NUNCA eliminar registros de:
# - wallettransactions (inmutables)
# - commissions (inmutables)
# - loyalty_points_history (inmutables)
# - nn_travel_points_history (inmutables)

# Solo marcar como CANCELLED o INACTIVE si es necesario
Performance
# Para 50,000 usuarios:
# - Wallets: 50k registros (~5 MB)
# - WalletTransactions: ~500k/a√±o (~150 MB/a√±o)
# - Queries deben ejecutar en <50ms con √≠ndices correctos