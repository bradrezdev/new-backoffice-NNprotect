Prompt para Implementación del Sistema de Puntos y Billetera Virtual - NN Protect MLM
📋 Contexto del Proyecto
Información General
Empresa: NN Protect - Marketing Multinivel con esquema Uninivel
Productos: Suplementos y cuidado de la piel con nanotecnología
Stack Tecnológico:
Framework: Reflex (Python-based)
ORM: SQLModel
Base de datos: Supabase (PostgreSQL)
Estado actual: ~5,700 usuarios activos (proyección: 50,000 en 2 años)
Arquitectura Actual
NNProtect_new_website/
├── database/              # Modelos SQLModel
│   ├── users.py          # Tabla de usuarios con member_id
│   ├── products.py       # 24 productos con precios por país
│   ├── orders.py         # Órdenes de compra
│   ├── order_items.py    # Detalles de productos en órdenes
│   ├── comissions.py     # ✅ Tabla EXISTENTE de comisiones
│   ├── periods.py        # Períodos mensuales de cálculo
│   ├── ranks.py          # Catálogo de rangos MLM
│   ├── user_rank_history.py  # Historial de rangos alcanzados
│   ├── usertreepaths.py  # Genealogía MLM (Path Enumeration)
│   └── exchange_rates.py # ✅ Tasas de cambio fijas
Países Operativos y Monedas
México: MXN
USA: USD
Colombia: COP
República Dominicana: DOP
Sistema de Doble Puntuación (CRÍTICO)
# PV (Personal Volume) - Para alcanzar rangos
pv = {
    "proposito": "SOLO para calificación de rangos",
    "caracteristica": "Valor uniforme global en todos los países",
    "ejemplo": "Producto Cúrcuma = 293 PV (igual en MX, USA, COP, DOP)"
}

# VN (Valor Negocio) - Para pagar comisiones
vn = {
    "proposito": "SOLO para calcular comisiones monetarias",
    "caracteristica": "Valor localizado por país",
    "ejemplo": "Cúrcuma = 293 VN (MXN), 21 VN (USD), 67,400 VN (COP)"
}
🎯 Requerimientos del Sistema
1. Puntos NN Travel
Sistema de acumulación de puntos para viajes mediante campañas semestrales.
Fuentes de Acumulación
A. Por Kits de Inicio Comprados en la Red
kits_puntos = {
    "full_supplement": {
        "puntos_base": 1,
        "precio_mx": 1996,
        "precio_usa": 120,
        "precio_cop": 479000
    },
    "full_skin": {
        "puntos_base": 2,
        "precio_mx": 2596,
        "precio_usa": 160,
        "precio_cop": 622800
    },
    "full_protect": {
        "puntos_base": 4,
        "precio_mx": 5790,
        "precio_usa": 353,
        "precio_cop": 1389000,
        "bonificacion_especial": "+1 punto si inscribes 5 Full Protect"
    }
}
B. Por Rangos Alcanzados por el Usuario
Rango	Puntos Base	Puntos en Promo
Visionario	1	2
Emprendedor	5	10
Creativo	15	30
Innovador	25	50
Embajador Transformador	50	100
Embajador Inspirador	100	200
Embajador Consciente	200	200
Embajador Solidario	200	200
C. Por Rangos Alcanzados por Directos (Nivel 1) Los directos generan puntos con valores específicos (ver tabla MLM_SCHEME_README líneas 852-862).
Reglas de Negocio
nn_travel_rules = {
    "meta_actual": 200,  # Puntos requeridos para calificar
    "periodo": "semestral",  # Campañas de 6 meses
    "acumulacion": "progresiva",  # Se acumulan durante toda la campaña
    "calificacion": "al_completar_200",
    "reseteo": "cada_nueva_campaña"
}
Estructura de Datos Requerida
⚠️ IMPORTANTE: No existe tabla campaigns, debe crearse.
class TravelCampaigns(rx.Model, table=True):
    """
    Campañas semestrales de NN Travels.
    """
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(max_length=100)  # "Campaña 2025-H1", "Campaña 2025-H2"
    start_date: datetime
    end_date: datetime
    target_points: int = Field(default=200)  # Meta de puntos
    is_promo_active: bool = Field(default=False)  # Si hay puntos duplicados
    period_id: int = Field(foreign_key="periods.id", index=True)  # Período asociado
    status: str = Field(default="active")  # active, closed
    created_at: datetime
Tabla Principal de Puntos
class NNTravelPoints(rx.Model, table=True):
    """
    Acumulación de puntos NN Travel por usuario y campaña.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    campaign_id: int = Field(foreign_key="travelcampaigns.id", index=True)
    
    # Desglose de puntos
    points_from_kits: int = Field(default=0)  # Puntos por kits vendidos
    points_from_self_ranks: int = Field(default=0)  # Puntos por rangos propios
    points_from_direct_ranks: int = Field(default=0)  # Puntos por rangos de directos
    points_bonus: int = Field(default=0)  # Bonificaciones especiales
    
    total_points: int = Field(default=0)  # Total acumulado
    qualifies_for_travel: bool = Field(default=False)  # Califica si >= 200
    
    created_at: datetime
    updated_at: datetime
    
    __table_args__ = (
        UniqueConstraint('member_id', 'campaign_id'),
    )
Historial de Eventos
class NNTravelPointsHistory(rx.Model, table=True):
    """
    Registro detallado de cada evento que genera puntos.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    campaign_id: int = Field(foreign_key="travelcampaigns.id", index=True)
    
    event_type: str  # "kit_purchase", "self_rank", "direct_rank", "bonus"
    points_earned: int
    source_member_id: int | None = Field(default=None)  # Si viene de directo
    source_order_id: int | None = Field(default=None)  # Si viene de compra
    rank_achieved: str | None = Field(default=None)  # Si es por rango
    
    description: str  # Descripción del evento
    created_at: datetime
2. Puntos de Lealtad
Sistema de fidelización con regalo físico cada 4 meses consecutivos.
Reglas de Negocio CRÍTICAS
loyalty_rules = {
    "puntos_por_mes": 25,
    "puntos_requeridos": 100,  # 4 meses consecutivos
    "ventana_compra": "día 1-7 del mes",  # SOLO estas fechas cuentan
    "regla_reinicio": "si_un_mes_falla_resetea_a_0",  # ⚠️ MUY IMPORTANTE
    "frecuencia": "cada_4_meses",
    "regalo": ["paquete_5_suplementos", "paquete_3_serums_2_cremas"]
}
Flujo de Acumulación
# Ejemplo del flujo crítico:
"""
Mes 1 (Ene 3): Compra → 25 puntos
Mes 2 (Feb 5): Compra → 50 puntos  
Mes 3 (Mar 15): NO compra en día 1-7 → REINICIO a 0 puntos ❌
Mes 4 (Abr 4): Compra → 25 puntos (comenzando de nuevo)
"""
Estructura de Datos Requerida
class LoyaltyPoints(rx.Model, table=True):
    """
    Balance de puntos de lealtad por usuario.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", unique=True, index=True)
    
    current_points: int = Field(default=0)  # 0-100, se reinicia al canjear
    consecutive_months: int = Field(default=0)  # Meses consecutivos acumulados
    last_valid_purchase_date: datetime | None = Field(default=None)
    
    status: str = Field(default="ACUMULANDO")  # ACUMULANDO, CALIFICADO, CANJEADO, REINICIADO
    
    created_at: datetime
    updated_at: datetime
class LoyaltyPointsHistory(rx.Model, table=True):
    """
    Historial completo de acumulaciones/reinicios.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    period_id: int = Field(foreign_key="periods.id", index=True)
    
    event_type: str  # "EARNED", "RESET", "REDEEMED"
    points_before: int
    points_after: int
    points_change: int  # +25, -100, etc.
    
    order_id: int | None = Field(default=None, foreign_key="orders.id")
    purchase_day: int | None = Field(default=None)  # Día del mes (1-31)
    
    description: str
    created_at: datetime
class LoyaltyRewards(rx.Model, table=True):
    """
    Registro de recompensas entregadas.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    
    reward_type: str  # "paquete_5_suplementos", "paquete_3_serums_2_cremas"
    delivery_order_id: int | None = Field(default=None, foreign_key="orders.id")
    
    earned_at: datetime  # Cuándo completó 100 puntos
    delivered_at: datetime | None = Field(default=None)  # Cuándo se entregó
    status: str = Field(default="PENDING")  # PENDING, DELIVERED
3. Cashback
Descuento del 70% aplicable en la misma orden al alcanzar 2,930 PV.
Reglas de Negocio ACTUALIZADAS
cashback_rules = {
    "requisito_pv": 2930,  # PV mínimo para activar
    "descuento_porcentaje": 70,  # 70% del precio público
    "base_calculo": "total_precio_publico",  # Precio público de TODOS los productos
    "productos_permitidos": "cualquier_producto_hasta_2930pv",
    "envio": "se_cobra_normal",  # El envío NO tiene descuento
    "activacion": "en_tiempo_real_en_carrito",  # Se activa al alcanzar 2930 PV
    "misma_orden": "si",  # Se puede añadir productos del cashback a la MISMA orden
    "valido_hasta": "fin_del_mes",
    "se_aplica_en": "siguiente_compra_o_misma_orden"
}
Flujo de Activación
# Ejemplo de flujo:
"""
1. Usuario añade productos al carrito
2. Sistema calcula PV acumulado en tiempo real
3. Al llegar a 2,930 PV → Sistema activa cashback
4. Usuario puede:
   a) Añadir más productos (hasta 2,930 PV adicionales) con 70% descuento
   b) O pagar y usar el cashback en siguiente compra del mismo mes
5. Descuento = 70% del precio público de los productos del cashback
6. Envío se cobra normal
"""
Estructura de Datos Requerida
class Cashback(rx.Model, table=True):
    """
    Registro de cashbacks generados y aplicados.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    period_id: int = Field(foreign_key="periods.id", index=True)
    
    # Orden que generó el cashback (alcanzó 2,930 PV)
    generated_by_order_id: int = Field(foreign_key="orders.id", index=True)
    pv_accumulated: int  # PV que generó el cashback (debe ser >= 2,930)
    
    # Monto del descuento (70% del precio público)
    discount_amount: float  # En moneda del usuario
    currency: str = Field(max_length=10)  # MXN, USD, COP, DOP
    
    # Aplicación del descuento
    applied_to_order_id: int | None = Field(default=None, foreign_key="orders.id")
    
    # Vigencia
    issued_at: datetime
    expires_at: datetime  # Fin del mes
    
    # Estado
    status: str = Field(default="AVAILABLE")  # AVAILABLE, USED, EXPIRED
    
    created_at: datetime
    updated_at: datetime
class CashbackUsage(rx.Model, table=True):
    """
    Detalle de productos comprados con cashback.
    """
    id: int | None = Field(default=None, primary_key=True)
    cashback_id: int = Field(foreign_key="cashback.id", index=True)
    order_id: int = Field(foreign_key="orders.id", index=True)
    order_item_id: int = Field(foreign_key="orderitems.id", index=True)
    
    product_id: int = Field(foreign_key="products.id")
    quantity: int
    
    original_price: float  # Precio público
    discount_applied: float  # 70% del precio público
    final_price: float  # 30% del precio público
    
    created_at: datetime
4. Billetera Virtual (Wallet)
Monedero electrónico interno donde se depositan comisiones y se realizan transacciones.
Funcionalidades Core
wallet_features = {
    "recibir_comisiones": [
        "bono_rapido",
        "bono_uninivel", 
        "bono_matching",
        "bono_alcance",
        "bono_automovil",
        "bono_travels",
        "bono_cashback",
        "bono_lealtad"
    ],
    "pagar_ordenes": "usar_balance_wallet",
    "transferencias": {
        "enviar": "a_otros_usuarios",
        "recibir": "de_otros_usuarios"
    },
    "retiros": {
        "destino": "cuenta_bancaria",
        "minimo": "definir_por_pais"
    }
}
Integración con Comisiones EXISTENTES
⚠️ CRÍTICO: Ya existe la tabla database/comissions.py con los siguientes campos:
class Commissions(rx.Model, table=True):
    id: int
    member_id: int  # Receptor
    bonus_type: str  # Tipo de bono
    source_member_id: int | None  # Origen
    source_order_id: int | None  # Orden origen
    period_id: int  # Período
    level_depth: int | None  # Nivel de profundidad
    amount_vn: float  # Monto en VN
    currency_origin: str  # Moneda origen
    amount_converted: float  # Monto convertido
    currency_destination: str  # Moneda destino
    exchange_rate: float  # Tasa usada
    status: str  # PENDING, PAID, CANCELLED
    calculated_at: datetime
    paid_at: datetime | None
    notes: str | None
Flujo de Integración Wallet ↔ Commissions
# Flujo completo:
"""
1. Sistema calcula comisiones → Inserta en tabla `commissions` (status: PENDING)
2. Job de procesamiento lee comisiones PENDING
3. Por cada comisión:
   a) Deposita monto en wallet del usuario (WalletTransaction tipo COMMISSION_DEPOSIT)
   b) Actualiza commissions.status = PAID
   c) Actualiza commissions.paid_at = now()
4. Usuario puede consultar:
   - Total ganado por tipo de bono (SUM commissions GROUP BY bonus_type)
   - Total ganado por nivel (SUM commissions GROUP BY level_depth)
   - Balance actual en wallet
"""
Estructura de Datos Requerida
class Wallets(rx.Model, table=True):
    """
    Billetera virtual por usuario (una por usuario).
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", unique=True, index=True)
    
    balance: float = Field(default=0.0)  # Balance actual (NUNCA negativo)
    currency: str = Field(max_length=10)  # MXN, USD, COP, DOP (según país del usuario)
    
    status: str = Field(default="ACTIVE")  # ACTIVE, SUSPENDED, CLOSED
    
    created_at: datetime
    updated_at: datetime  # Se actualiza en cada transacción
    
    __table_args__ = (
        CheckConstraint('balance >= 0', name='balance_non_negative'),
    )
class WalletTransactionType(Enum):
    """Tipos de transacciones de billetera"""
    # Entradas (créditos)
    COMMISSION_DEPOSIT = "commission_deposit"  # Depósito de comisión
    TRANSFER_IN = "transfer_in"  # Transferencia recibida
    REFUND = "refund"  # Devolución
    ADJUSTMENT_CREDIT = "adjustment_credit"  # Ajuste administrativo positivo
    
    # Salidas (débitos)
    ORDER_PAYMENT = "order_payment"  # Pago de orden
    TRANSFER_OUT = "transfer_out"  # Transferencia enviada
    WITHDRAWAL_REQUEST = "withdrawal_request"  # Solicitud de retiro
    WITHDRAWAL_COMPLETED = "withdrawal_completed"  # Retiro completado
    WITHDRAWAL_REJECTED = "withdrawal_rejected"  # Retiro rechazado (reversa)
    ADJUSTMENT_DEBIT = "adjustment_debit"  # Ajuste administrativo negativo

class WalletTransactionStatus(Enum):
    """Estados de transacción"""
    PENDING = "pending"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class WalletTransactions(rx.Model, table=True):
    """
    Registro inmutable de todas las transacciones de billetera.
    CADA transacción debe quedar registrada permanentemente.
    """
    id: int | None = Field(default=None, primary_key=True)
    transaction_uuid: str = Field(unique=True, index=True)  # UUID para idempotencia
    
    # Usuario propietario de la wallet
    member_id: int = Field(foreign_key="users.member_id", index=True)
    
    # Tipo y estado
    transaction_type: str = Field(max_length=50, index=True)  # Enum WalletTransactionType
    status: str = Field(default="PENDING", index=True)  # Enum WalletTransactionStatus
    
    # Montos (puede ser negativo para débitos)
    amount: float  # Monto de la transacción (+ para crédito, - para débito)
    balance_before: float  # Balance ANTES de la transacción
    balance_after: float  # Balance DESPUÉS de la transacción
    currency: str = Field(max_length=10)
    
    # Referencias externas
    commission_id: int | None = Field(default=None, foreign_key="commissions.id", index=True)
    order_id: int | None = Field(default=None, foreign_key="orders.id", index=True)
    transfer_to_member_id: int | None = Field(default=None, foreign_key="users.member_id")
    transfer_from_member_id: int | None = Field(default=None, foreign_key="users.member_id")
    
    # Metadatos
    description: str  # Descripción legible
    notes: str | None = Field(default=None, max_length=500)
    metadata_json: str | None = Field(default=None)  # JSON para datos adicionales
    
    # Timestamps (UTC puro)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={"server_default": func.now()}
    )
    completed_at: datetime | None = Field(default=None)
    
    # Índices compuestos
    __table_args__ = (
        Index('idx_member_type', 'member_id', 'transaction_type'),
        Index('idx_member_status', 'member_id', 'status'),
        Index('idx_member_created', 'member_id', 'created_at'),
    )
class WalletWithdrawals(rx.Model, table=True):
    """
    Solicitudes de retiro a cuenta bancaria.
    """
    id: int | None = Field(default=None, primary_key=True)
    member_id: int = Field(foreign_key="users.member_id", index=True)
    wallet_transaction_id: int = Field(foreign_key="wallettransactions.id", unique=True)
    
    amount: float  # Monto solicitado
    currency: str = Field(max_length=10)
    
    # Datos bancarios (encriptados en producción)
    bank_name: str = Field(max_length=100)
    account_number: str = Field(max_length=50)
    account_holder_name: str = Field(max_length=150)
    
    # Estado y procesamiento
    status: str = Field(default="PENDING")  # PENDING, PROCESSING, COMPLETED, REJECTED
    rejection_reason: str | None = Field(default=None)
    
    requested_at: datetime
    processed_at: datetime | None = Field(default=None)
    completed_at: datetime | None = Field(default=None)
📊 Requerimientos de Visualización y Reportes
Dashboard del Usuario
El sistema debe permitir visualizar:
user_dashboard_requirements = {
    "comisiones_por_bono": {
        "query": "SELECT bonus_type, SUM(amount_converted) FROM commissions WHERE member_id=X GROUP BY bonus_type",
        "visualizacion": "Gráfico de barras o tabla"
    },
    "comisiones_por_nivel": {
        "query": "SELECT level_depth, SUM(amount_converted) FROM commissions WHERE member_id=X AND bonus_type='bono_uninivel' GROUP BY level_depth",
        "visualizacion": "Gráfico de líneas por profundidad"
    },
    "balance_wallet": {
        "query": "SELECT balance FROM wallets WHERE member_id=X",
        "tiempo_real": True
    },
    "historial_transacciones": {
        "query": "SELECT * FROM wallettransactions WHERE member_id=X ORDER BY created_at DESC",
        "paginacion": True,
        "filtros": ["tipo", "fecha", "estado"]
    }
}
🔧 Especificaciones Técnicas Generales
Convenciones de Código
# 1. Nombres de tablas: snake_case plural
# Correcto: wallets, wallet_transactions, loyalty_points
# Incorrecto: Wallet, walletTransaction, LoyaltyPoint

# 2. Campos comunes en TODAS las tablas
common_fields = {
    "id": "int | None = Field(default=None, primary_key=True)",
    "created_at": "datetime (UTC puro)",
    "updated_at": "datetime (UTC puro, opcional según tabla)"
}

# 3. Montos monetarios: siempre Decimal o float con 2 decimales
amount: float = Field(default=0.0)  # Para montos
balance: float = Field(default=0.0)  # Para balances

# 4. Foreign Keys: siempre con ondelete apropiado
member_id: int = Field(foreign_key="users.member_id", index=True)

# 5. Timestamps: SIEMPRE en UTC puro
from datetime import datetime, timezone

created_at: datetime = Field(
    default_factory=lambda: datetime.now(timezone.utc),
    sa_column_kwargs={"server_default": func.now()}
)

# 6. Enums: siempre como clase Enum de Python
from enum import Enum

class StatusType(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"
Índices Requeridos
# Índices críticos para performance:

# Wallets
CREATE INDEX idx_wallet_member ON wallets(member_id);

# WalletTransactions
CREATE INDEX idx_wt_member_type ON wallettransactions(member_id, transaction_type);
CREATE INDEX idx_wt_member_created ON wallettransactions(member_id, created_at);
CREATE INDEX idx_wt_commission ON wallettransactions(commission_id);
CREATE INDEX idx_wt_order ON wallettransactions(order_id);

# NNTravelPoints
CREATE INDEX idx_nntp_member_campaign ON nntravelpoints(member_id, campaign_id);
CREATE INDEX idx_nntp_campaign ON nntravelpoints(campaign_id);

# LoyaltyPoints
CREATE INDEX idx_lp_member ON loyaltypoints(member_id);
CREATE INDEX idx_lp_status ON loyaltypoints(status);

# Cashback
CREATE INDEX idx_cb_member_period ON cashback(member_id, period_id);
CREATE INDEX idx_cb_status ON cashback(status);
Validaciones Críticas
validations = {
    "wallet_balance": "NUNCA puede ser negativo (CHECK CONSTRAINT)",
    "transaction_atomicity": "Transferencias deben ser atómicas (2 registros: OUT + IN)",
    "idempotency": "Usar transaction_uuid para evitar duplicados",
    "commission_deposit": "Validar que commission.status == PENDING antes de depositar",
    "cashback_pv": "Validar que PV >= 2930 antes de generar cashback",
    "loyalty_day_validation": "Validar que compra sea entre día 1-7 del mes"
}
Constraints de Integridad
# Ejemplos de constraints necesarios:

# 1. Balance no negativo
__table_args__ = (
    CheckConstraint('balance >= 0', name='balance_non_negative'),
)

# 2. Unicidad compuesta
__table_args__ = (
    UniqueConstraint('member_id', 'campaign_id', name='unique_member_campaign'),
)

# 3. Foreign keys con comportamiento
member_id: int = Field(
    foreign_key="users.member_id",
    sa_column_kwargs={"ondelete": "CASCADE"}  # O "RESTRICT" según caso
)
🎯 Casos de Uso Críticos a Soportar
1. Depósito de Comisión a Wallet
"""
Flow:
1. Sistema calcula comisiones mensuales → Inserta en `commissions` (PENDING)
2. Job procesa comisiones PENDING
3. Por cada comisión:
   a) Leer wallets.balance actual
   b) Crear WalletTransaction:
      - type: COMMISSION_DEPOSIT
      - amount: commission.amount_converted
      - balance_before: balance actual
      - balance_after: balance + amount
      - commission_id: commission.id
   c) Actualizar wallets.balance += amount
   d) Actualizar commissions.status = PAID, paid_at = now()
4. Commit transacción completa (todo o nada)
"""
2. Usuario Paga Orden con Wallet
"""
Flow:
1. Usuario confirma orden
2. Sistema valida: wallet.balance >= order.total
3. Si suficiente:
   a) Crear WalletTransaction:
      - type: ORDER_PAYMENT
      - amount: -order.total (negativo)
      - balance_before: balance actual
      - balance_after: balance - order.total
      - order_id: order.id
   b) Actualizar wallets.balance -= order.total
   c) Actualizar orders.payment_method = "wallet"
   d) Actualizar orders.payment_confirmed_at = now()
4. Commit transacción
"""
3. Transferencia entre Usuarios
"""
Flow:
1. Usuario A transfiere $500 a Usuario B
2. Validar: wallet_A.balance >= 500
3. Crear DOS transacciones (atómicamente):
   
   a) Transacción OUT (Usuario A):
      - type: TRANSFER_OUT
      - amount: -500
      - balance_before: balance_A
      - balance_after: balance_A - 500
      - transfer_to_member_id: user_B.id
   
   b) Transacción IN (Usuario B):
      - type: TRANSFER_IN
      - amount: +500
      - balance_before: balance_B
      - balance_after: balance_B + 500
      - transfer_from_member_id: user_A.id
   
4. Actualizar ambos wallets.balance
5. Commit TODO junto (rollback si falla cualquier paso)
"""
4. Activación Automática de Cashback
"""
Flow:
1. Usuario añade productos al carrito
2. Frontend calcula PV en tiempo real
3. Cuando PV >= 2930:
   a) Backend valida PV acumulado
   b) Calcula descuento 70% del precio público
   c) Crea registro en tabla `cashback`:
      - generated_by_order_id: order.id (puede ser NULL si aún no se paga)
      - discount_amount: total_precio_publico * 0.70
      - expires_at: fin del mes
      - status: AVAILABLE
   d) Frontend muestra descuento disponible
4. Usuario puede:
   - Añadir más productos con descuento en misma orden
   - O usar descuento en siguiente compra del mes
"""
5. Reset de Puntos de Lealtad
"""
Flow (Job automático día 8 de cada mes):
1. Leer todos los usuarios con loyalty_points > 0
2. Por cada usuario:
   a) Verificar si hubo compra entre día 1-7 del mes anterior
   b) Si NO hubo compra:
      - Crear LoyaltyPointsHistory:
        - event_type: RESET
        - points_before: puntos actuales
        - points_after: 0
        - description: "Reinicio por falta de compra en ventana 1-7"
      - Actualizar loyalty_points.current_points = 0
      - Actualizar loyalty_points.consecutive_months = 0
      - Actualizar loyalty_points.status = REINICIADO
3. Commit cambios
"""
📋 Entregables Esperados
Archivos a Crear
database/nn_travel_points.py
Clase TravelCampaigns
Clase NNTravelPoints
Clase NNTravelPointsHistory
database/loyalty_points.py
Clase LoyaltyPoints
Clase LoyaltyPointsHistory
Clase LoyaltyRewards
database/cashback.py
Clase Cashback
Clase CashbackUsage
Enums: CashbackStatus
database/wallet.py
Clase Wallets
Clase WalletTransactions
Clase WalletWithdrawals
Enums: WalletTransactionType, WalletTransactionStatus
Características de Cada Archivo
# Estructura esperada de cada archivo:

"""
1. Imports correctos
   - import reflex as rx
   - from sqlmodel import Field, func, Index, UniqueConstraint, CheckConstraint
   - from datetime import datetime, timezone
   - from enum import Enum

2. Enums (si aplica)
   - Definir todos los estados/tipos como Enum

3. Modelos SQLModel
   - Heredar de rx.Model
   - table=True
   - Docstrings explicativos en español
   - Type hints correctos
   - Foreign keys apropiados
   - Índices necesarios
   - Constraints de validación

4. Métodos helper (opcional pero recomendado)
   - Métodos de instancia útiles
   - Properties calculadas
   - Validaciones custom

5. Comentarios explicativos
   - Para reglas de negocio complejas
   - Para campos críticos
   - Para constraints importantes
"""
✅ Checklist de Validación
Antes de entregar, verificar:
 Todos los modelos heredan de rx.Model con table=True
 Todos los timestamps están en UTC puro
 Todos los montos usan float o Decimal
 Todas las Foreign Keys tienen índices
 Constraints de validación implementados (CHECK, UNIQUE)
 Enums definidos para estados y tipos
 Campos created_at y updated_at donde corresponda
 Índices compuestos para queries frecuentes
 Docstrings en español en todas las clases
 Nombres de tablas en snake_case plural
 Compatibilidad con tablas existentes (users, orders, commissions, periods)
 Validación de que cashback se conecta con orders
 Validación de que wallet_transactions se conecta con commissions
 Validación de que travel_campaigns tiene period_id
🚨 Consideraciones Críticas Finales
Atomicidad de Transacciones
# TODAS las operaciones de wallet deben ser atómicas:
with db.begin():
    # 1. Validar balance
    # 2. Crear WalletTransaction
    # 3. Actualizar Wallets.balance
    # 4. Actualizar tabla relacionada (commissions, orders, etc.)
    # Si CUALQUIER paso falla → ROLLBACK completo
Idempotencia
# Usar transaction_uuid para evitar duplicados:
transaction_uuid = str(uuid.uuid4())

# Antes de insertar, verificar:
existing = db.query(WalletTransactions).filter(
    WalletTransactions.transaction_uuid == transaction_uuid
).first()

if existing:
    return existing  # Ya procesado, no duplicar
Auditoría Completa
# NUNCA eliminar registros de:
# - wallettransactions (inmutables)
# - commissions (inmutables)
# - loyalty_points_history (inmutables)
# - nn_travel_points_history (inmutables)

# Solo marcar como CANCELLED o INACTIVE si es necesario
Performance
# Para 50,000 usuarios:
# - Wallets: 50k registros (~5 MB)
# - WalletTransactions: ~500k/año (~150 MB/año)
# - Queries deben ejecutar en <50ms con índices correctos